<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title></title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for xEnricherGenes"><tr><td>xEnricherGenes</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>xEnricherGenes</h2>

<h3>Usage</h3>

<pre>
xEnricherGenes(data, background = NULL, check.symbol.identity = F,
ontology = c("GOBP", "GOMF", "GOCC", "PS", "PS2", "SF", "Pfam", "DO",
"HPPA", "HPMI", "HPCM", "HPMA", "MP", "EF", "MsigdbH", "MsigdbC1",
"MsigdbC2CGP", "MsigdbC2CPall", "MsigdbC2CP", "MsigdbC2KEGG",
"MsigdbC2REACTOME", "MsigdbC2BIOCARTA", "MsigdbC3TFT", "MsigdbC3MIR",
"MsigdbC4CGN", "MsigdbC4CM", "MsigdbC5BP", "MsigdbC5MF", "MsigdbC5CC",
"MsigdbC6", "MsigdbC7", "DGIdb", "GTExV4", "GTExV6", "CreedsDisease",
"CreedsDiseaseUP", "CreedsDiseaseDN", "CreedsDrug", "CreedsDrugUP",
"CreedsDrugDN", "CreedsGene", "CreedsGeneUP",
"CreedsGeneDN"), size.range = c(10, 2000), min.overlap = 3,
which.distance = NULL, test = c("hypergeo", "fisher", "binomial"),
p.adjust.method = c("BH", "BY", "bonferroni", "holm", "hochberg",
"hommel"), ontology.algorithm = c("none", "pc", "elim", "lea"),
elim.pvalue = 0.01, lea.depth = 2, path.mode = c("all_paths",
"shortest_paths", "all_shortest_paths"), true.path.rule = F, verbose =
T, RData.location = "http://galahad.well.ox.ac.uk/bigdata")
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>data</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>background</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>check.symbol.identity</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>ontology</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>size.range</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>min.overlap</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>which.distance</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>test</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>p.adjust.method</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>ontology.algorithm</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>elim.pvalue</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>lea.depth</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>path.mode</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>true.path.rule</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>verbose</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>RData.location</code></td>
<td>


</td></tr>
</table>


<h3>Examples</h3>

<pre>
##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (data, background = NULL, check.symbol.identity = F,
ontology = c("GOBP", "GOMF", "GOCC", "PS", "PS2", "SF", "Pfam",
"DO", "HPPA", "HPMI", "HPCM", "HPMA", "MP", "EF", "MsigdbH",
"MsigdbC1", "MsigdbC2CGP", "MsigdbC2CPall", "MsigdbC2CP",
"MsigdbC2KEGG", "MsigdbC2REACTOME", "MsigdbC2BIOCARTA",
"MsigdbC3TFT", "MsigdbC3MIR", "MsigdbC4CGN", "MsigdbC4CM",
"MsigdbC5BP", "MsigdbC5MF", "MsigdbC5CC", "MsigdbC6",
"MsigdbC7", "DGIdb", "GTExV4", "GTExV6", "CreedsDisease",
"CreedsDiseaseUP", "CreedsDiseaseDN", "CreedsDrug", "CreedsDrugUP",
"CreedsDrugDN", "CreedsGene", "CreedsGeneUP", "CreedsGeneDN"),
size.range = c(10, 2000), min.overlap = 3, which.distance = NULL,
test = c("hypergeo", "fisher", "binomial"), p.adjust.method = c("BH",
"BY", "bonferroni", "holm", "hochberg", "hommel"), ontology.algorithm =
c("none",
"pc", "elim", "lea"), elim.pvalue = 0.01, lea.depth = 2,
path.mode = c("all_paths", "shortest_paths", "all_shortest_paths"),
true.path.rule = F, verbose = T, RData.location =
"http://galahad.well.ox.ac.uk/bigdata")
{
startT &lt;- Sys.time()
message(paste(c("Start at ", as.character(startT)), collapse = ""),
appendLF = T)
message("", appendLF = T)
ontology &lt;- match.arg(ontology)
test &lt;- match.arg(test)
p.adjust.method &lt;- match.arg(p.adjust.method)
ontology.algorithm &lt;- match.arg(ontology.algorithm)
path.mode &lt;- match.arg(path.mode)
if (length(data) == 0) {
return(FALSE)
}
if (is.vector(data)) {
data &lt;- unique(data)
}
else {
stop("The input data must be a vector.\n")
}
data &lt;- as.character(data)
if (!is.na(ontology)) {
if (verbose) {
now &lt;- Sys.time()
message(sprintf("Load the ontology %s and its gene annotations (%s)
...",
ontology, as.character(now)), appendLF = T)
}
flag_PS2 &lt;- FALSE
if (ontology == "PS2") {
flag_PS2 &lt;- TRUE
ontology &lt;- "PS"
}
GS &lt;- xRDataLoader(RData.customised = paste("org.Hs.eg",
ontology, sep = ""), RData.location = RData.location,
verbose = verbose)
if (flag_PS2) {
tmp &lt;- as.character(unique(GS$set_info$name))
inds &lt;- sapply(tmp, function(x) which(GS$set_info$name ==
x))
set_info &lt;- data.frame()
for (i in 1:length(inds)) {
set_info &lt;- rbind(set_info, as.matrix(GS$set_info[max(inds[[i]]),
]))
}
gs &lt;- list()
for (i in 1:length(inds)) {
gs[[i]] &lt;- unlist(GS$gs[inds[[i]]], use.names = F)
}
names(gs) &lt;- rownames(set_info)
GS$set_info &lt;- set_info
GS$gs &lt;- gs
}
anno &lt;- GS$gs
all.ontologies &lt;- c("GOBP", "GOMF", "GOCC", "DO", "HPPA",
"HPMI", "HPCM", "HPMA", "MP", "EF")
flag_ontology &lt;- ontology %in% all.ontologies
if (flag_ontology) {
g &lt;- xRDataLoader(RData.customised = paste("ig.",
ontology, sep = ""), RData.location = RData.location,
verbose = verbose)
}
else {
ontology.algorithm &lt;- "none"
nodes &lt;- data.frame(name = as.character(GS$set_info$setID),
term_id = as.character(GS$set_info$setID), term_name =
as.character(GS$set_info$name),
term_distance = as.character(GS$set_info$distance),
stringsAsFactors = F)
nodes &lt;- rbind(nodes, c("root", "root", "root", "root"))
relations &lt;- data.frame(from = "root", to = nodes$name)
g &lt;- igraph::graph.data.frame(d = relations, directed = T,
vertices = nodes)
}
}
else {
stop("There is no input for the ontology.\n")
}
if (verbose) {
now &lt;- Sys.time()
message(sprintf("Do gene mapping from Symbols to EntrezIDs (%s) ...",
as.character(now)), appendLF = T)
}
data &lt;- xSymbol2GeneID(data, check.symbol.identity =
check.symbol.identity,
verbose = verbose, RData.location = RData.location)
data &lt;- data[!is.na(data)]
if (length(background) &gt; 0) {
background &lt;- xSymbol2GeneID(background, check.symbol.identity =
check.symbol.identity,
verbose = verbose, RData.location = RData.location)
background &lt;- background[!is.na(background)]
}
if (verbose) {
now &lt;- Sys.time()
message(sprintf("\n#######################################################",
appendLF = T))
message(sprintf("'xEnricher' is being called (%s):",
as.character(now)), appendLF = T)
message(sprintf("#######################################################",
appendLF = T))
}
eTerm &lt;- xEnricher(data = data, annotation = anno, g = g,
background = background, size.range = size.range, min.overlap =
min.overlap,
which.distance = which.distance, test = test, p.adjust.method =
p.adjust.method,
ontology.algorithm = ontology.algorithm, elim.pvalue = elim.pvalue,
lea.depth = lea.depth, path.mode = path.mode, true.path.rule =
true.path.rule,
verbose = verbose)
if (1 &amp; class(eTerm) == "eTerm") {
EG &lt;- xRDataLoader(RData.customised = paste("org.Hs.eg",
sep = ""), RData.location = RData.location, verbose = verbose)
allGeneID &lt;- EG$gene_info$GeneID
allSymbol &lt;- as.vector(EG$gene_info$Symbol)
overlap &lt;- eTerm$overlap
overlap_symbols &lt;- lapply(overlap, function(x) {
ind &lt;- match(x, allGeneID)
allSymbol[ind]
})
eTerm$overlap &lt;- overlap_symbols
eTerm$data &lt;- allSymbol[match(eTerm$data, allGeneID)]
eTerm$background &lt;- allSymbol[match(eTerm$background,
allGeneID)]
}
if (verbose) {
now &lt;- Sys.time()
message(sprintf("#######################################################",
appendLF = T))
message(sprintf("'xEnricher' has been finished (%s)!",
as.character(now)), appendLF = T)
message(sprintf("#######################################################\n",
appendLF = T))
}
endT &lt;- Sys.time()
message(paste(c("\nEnd at ", as.character(endT)), collapse = ""),
appendLF = T)
runTime &lt;- as.numeric(difftime(strptime(endT, "%Y-%m-%d
%H:%M:%S"),
strptime(startT, "%Y-%m-%d %H:%M:%S"), units = "secs"))
message(paste(c("Runtime in total is: ", runTime, " secs\n"),
collapse = ""), appendLF = T)
invisible(eTerm)
}
</pre>


</body></html>
