<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title></title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for xGRviaGenomicAnno"><tr><td>xGRviaGenomicAnno</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>xGRviaGenomicAnno</h2>

<h3>Usage</h3>

<pre>
xGRviaGenomicAnno(data.file, annotation.file = NULL, background.file =
NULL, format.file = c("data.frame", "bed", "chr:start-end", "GRanges"),
build.conversion = c(NA, "hg38.to.hg19", "hg18.to.hg19"), resolution =
c("bases", "regions", "hybrid"), background.annotatable.only = T,
p.tail = c("one-tail", "two-tails"), p.adjust.method = c("BH", "BY",
"bonferroni", "holm", "hochberg", "hommel"), GR.annotation = c(NA,
"Uniform_TFBS", "ENCODE_TFBS_ClusteredV3",
"ENCODE_TFBS_ClusteredV3_CellTypes", "Uniform_DNaseI_HS",
"ENCODE_DNaseI_ClusteredV3", "ENCODE_DNaseI_ClusteredV3_CellTypes",
"Broad_Histone", "SYDH_Histone", "UW_Histone", "FANTOM5_Enhancer_Cell",
"FANTOM5_Enhancer_Tissue", "FANTOM5_Enhancer_Extensive",
"FANTOM5_Enhancer", "Segment_Combined_Gm12878",
"Segment_Combined_H1hesc", "Segment_Combined_Helas3",
"Segment_Combined_Hepg2", "Segment_Combined_Huvec",
"Segment_Combined_K562", "TFBS_Conserved",
"TS_miRNA", "TCGA", "ReMap_Public_TFBS", "ReMap_Public_mergedTFBS",
"ReMap_PublicAndEncode_mergedTFBS", "ReMap_Encode_TFBS",
"Blueprint_BoneMarrow_Histone", "Blueprint_CellLine_Histone",
"Blueprint_CordBlood_Histone", "Blueprint_Thymus_Histone",
"Blueprint_VenousBlood_Histone", "Blueprint_DNaseI",
"Blueprint_Methylation_hyper", "Blueprint_Methylation_hypo",
"EpigenomeAtlas_15Segments_E029", "EpigenomeAtlas_15Segments_E030",
"EpigenomeAtlas_15Segments_E031", "EpigenomeAtlas_15Segments_E032",
"EpigenomeAtlas_15Segments_E033",
"EpigenomeAtlas_15Segments_E034", "EpigenomeAtlas_15Segments_E035",
"EpigenomeAtlas_15Segments_E036", "EpigenomeAtlas_15Segments_E037",
"EpigenomeAtlas_15Segments_E038", "EpigenomeAtlas_15Segments_E039",
"EpigenomeAtlas_15Segments_E040", "EpigenomeAtlas_15Segments_E041",
"EpigenomeAtlas_15Segments_E042", "EpigenomeAtlas_15Segments_E043",
"EpigenomeAtlas_15Segments_E044", "EpigenomeAtlas_15Segments_E045",
"EpigenomeAtlas_15Segments_E046", "EpigenomeAtlas_15Segments_E047",
"EpigenomeAtlas_15Segments_E048",
"EpigenomeAtlas_15Segments_E050", "EpigenomeAtlas_15Segments_E051",
"EpigenomeAtlas_15Segments_E062"), verbose = T, RData.location =
"http://galahad.well.ox.ac.uk/bigdata")
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>data.file</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>annotation.file</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>background.file</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>format.file</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>build.conversion</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>resolution</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>background.annotatable.only</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>p.tail</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>p.adjust.method</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>GR.annotation</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>verbose</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>RData.location</code></td>
<td>


</td></tr>
</table>


<h3>Examples</h3>

<pre>
##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (data.file, annotation.file = NULL, background.file = NULL,
format.file = c("data.frame", "bed", "chr:start-end", "GRanges"),
build.conversion = c(NA, "hg38.to.hg19", "hg18.to.hg19"),
resolution = c("bases", "regions", "hybrid"),
background.annotatable.only = T,
p.tail = c("one-tail", "two-tails"), p.adjust.method = c("BH",
"BY", "bonferroni", "holm", "hochberg", "hommel"), GR.annotation =
c(NA,
"Uniform_TFBS", "ENCODE_TFBS_ClusteredV3",
"ENCODE_TFBS_ClusteredV3_CellTypes",
"Uniform_DNaseI_HS", "ENCODE_DNaseI_ClusteredV3",
"ENCODE_DNaseI_ClusteredV3_CellTypes",
"Broad_Histone", "SYDH_Histone", "UW_Histone", "FANTOM5_Enhancer_Cell",
"FANTOM5_Enhancer_Tissue", "FANTOM5_Enhancer_Extensive",
"FANTOM5_Enhancer", "Segment_Combined_Gm12878",
"Segment_Combined_H1hesc",
"Segment_Combined_Helas3", "Segment_Combined_Hepg2",
"Segment_Combined_Huvec", "Segment_Combined_K562", "TFBS_Conserved",
"TS_miRNA", "TCGA", "ReMap_Public_TFBS", "ReMap_Public_mergedTFBS",
"ReMap_PublicAndEncode_mergedTFBS", "ReMap_Encode_TFBS",
"Blueprint_BoneMarrow_Histone", "Blueprint_CellLine_Histone",
"Blueprint_CordBlood_Histone", "Blueprint_Thymus_Histone",
"Blueprint_VenousBlood_Histone", "Blueprint_DNaseI",
"Blueprint_Methylation_hyper", "Blueprint_Methylation_hypo",
"EpigenomeAtlas_15Segments_E029", "EpigenomeAtlas_15Segments_E030",
"EpigenomeAtlas_15Segments_E031", "EpigenomeAtlas_15Segments_E032",
"EpigenomeAtlas_15Segments_E033", "EpigenomeAtlas_15Segments_E034",
"EpigenomeAtlas_15Segments_E035", "EpigenomeAtlas_15Segments_E036",
"EpigenomeAtlas_15Segments_E037", "EpigenomeAtlas_15Segments_E038",
"EpigenomeAtlas_15Segments_E039", "EpigenomeAtlas_15Segments_E040",
"EpigenomeAtlas_15Segments_E041", "EpigenomeAtlas_15Segments_E042",
"EpigenomeAtlas_15Segments_E043", "EpigenomeAtlas_15Segments_E044",
"EpigenomeAtlas_15Segments_E045", "EpigenomeAtlas_15Segments_E046",
"EpigenomeAtlas_15Segments_E047", "EpigenomeAtlas_15Segments_E048",
"EpigenomeAtlas_15Segments_E050", "EpigenomeAtlas_15Segments_E051",
"EpigenomeAtlas_15Segments_E062"), verbose = T, RData.location =
"http://galahad.well.ox.ac.uk/bigdata")
{
startT &lt;- Sys.time()
message(paste(c("Start at ", as.character(startT)), collapse = ""),
appendLF = T)
message("", appendLF = T)
format.file &lt;- match.arg(format.file)
build.conversion &lt;- match.arg(build.conversion)
resolution &lt;- match.arg(resolution)
p.adjust.method &lt;- match.arg(p.adjust.method)
p.tail &lt;- match.arg(p.tail)
if (verbose) {
now &lt;- Sys.time()
message(sprintf("First, import the files formatted as '%s' (%s) ...",
format.file, as.character(now)), appendLF = T)
}
if (verbose) {
now &lt;- Sys.time()
message(sprintf("\timport the data file (%s) ...", as.character(now)),
appendLF = T)
}
if (is.matrix(data.file) | is.data.frame(data.file) | class(data.file)
==
"GRanges") {
data &lt;- data.file
}
else if (!is.null(data.file) &amp; any(!is.na(data.file))) {
if (length(data.file) == 1) {
data &lt;- utils::read.delim(file = data.file, header = F,
row.names = NULL, stringsAsFactors = F)
}
else {
data &lt;- data.file
}
}
else {
stop("The file 'data.file' must be provided!\n")
}
if (verbose) {
now &lt;- Sys.time()
message(sprintf("\timport the annotation file (%s) ...",
as.character(now)), appendLF = T)
}
if (is.matrix(annotation.file) | is.data.frame(annotation.file) |
class(annotation.file) == "list") {
annotation &lt;- annotation.file
}
else if (!is.null(annotation.file)) {
annotation &lt;- utils::read.delim(file = annotation.file,
header = F, row.names = NULL, stringsAsFactors = F)
}
else {
message("\t\tThe file 'annotation.file' is not provided, so built-in
RData will be used instead!")
annotation &lt;- NULL
}
if (verbose) {
now &lt;- Sys.time()
message(sprintf("\timport the background file (%s) ...",
as.character(now)), appendLF = T)
}
if (is.matrix(background.file) | is.data.frame(background.file) |
class(background.file) == "GRanges") {
background &lt;- background.file
}
else if (!is.null(background.file)) {
if (length(background.file) == 1) {
background &lt;- utils::read.delim(file = background.file,
header = F, row.names = NULL, stringsAsFactors = F)
background &lt;- unique(background[, 1])
}
else {
background &lt;- background.file
}
}
else {
background &lt;- NULL
}
if (verbose) {
now &lt;- Sys.time()
message(sprintf("Second, construct GenomicRanges object (%s) ...",
as.character(now)), appendLF = T)
}
if (format.file == "data.frame") {
if (ncol(data) &gt;= 3) {
data &lt;- data
}
else if (ncol(data) == 2) {
data &lt;- cbind(data, data[, 2])
}
else {
stop("Your input 'data.file' is not as expected!\n")
}
ind &lt;- suppressWarnings(which(!is.na(as.numeric(data[,
2])) &amp; !is.na(as.numeric(data[, 3]))))
data &lt;- data[ind, ]
dGR &lt;- GenomicRanges::GRanges(seqnames = S4Vectors::Rle(data[,
1]), ranges = IRanges::IRanges(start = as.numeric(data[,
2]), end = as.numeric(data[, 3])), strand = S4Vectors::Rle(rep("*",
nrow(data))))
if (!is.null(annotation)) {
if (ncol(annotation) &gt;= 4) {
annotation &lt;- annotation
}
else {
stop("Your input 'annotation.file' is not as expected!\n")
}
anno_ls &lt;- split(x = annotation[, -4], f = annotation[,
4])
aGR &lt;- base::lapply(anno_ls, function(x) {
ind &lt;- suppressWarnings(which(!is.na(as.numeric(x[,
2])) &amp; !is.na(as.numeric(x[, 3]))))
x &lt;- x[ind, ]
gr &lt;- GenomicRanges::GRanges(seqnames = S4Vectors::Rle(x[,
1]), ranges = IRanges::IRanges(start = as.numeric(x[,
2]), end = as.numeric(x[, 3])), strand = S4Vectors::Rle(rep("*",
nrow(x))))
})
}
else {
if (class(GR.annotation) == "GRanges") {
aGR &lt;- GR.annotation
}
else {
if (is.na(GR.annotation)) {
stop("Please specify annotation RData!\n")
}
else {
if (length(GR.annotation) &gt; 1) {
message("\tONLY the first specified annotation RData will be used!\n")
GR.annotation &lt;- GR.annotation[1]
}
aGR &lt;- xRDataLoader(RData.customised = GR.annotation,
verbose = verbose, RData.location = RData.location)
if (is.null(aGR)) {
stop("Your specified annotation RData does not exist!\n")
}
}
}
}
if (!is.null(background)) {
if (ncol(background) &gt;= 3) {
background &lt;- background
}
else if (ncol(background) == 2) {
background &lt;- cbind(background, background[,
2])
}
else {
stop("Your input 'background.file' is not as expected!\n")
}
ind &lt;- suppressWarnings(which(!is.na(as.numeric(background[,
2])) &amp; !is.na(as.numeric(background[, 3]))))
background &lt;- background[ind, ]
bGR &lt;- GenomicRanges::GRanges(seqnames = S4Vectors::Rle(background[,
1]), ranges = IRanges::IRanges(start = as.numeric(background[,
2]), end = as.numeric(background[, 3])), strand =
S4Vectors::Rle(rep("*",
nrow(background))))
}
else {
bGR &lt;- NULL
}
}
else if (format.file == "chr:start-end") {
input &lt;- do.call(rbind, strsplit(data[, 1], ":|-"))
if (ncol(input) &gt;= 3) {
data &lt;- input
}
else if (ncol(input) == 2) {
data &lt;- cbind(input, input[, 2])
}
else {
stop("Your input 'data.file' does not meet the format
'chr:start-end'!\n")
}
ind &lt;- suppressWarnings(which(!is.na(as.numeric(data[,
2])) &amp; !is.na(as.numeric(data[, 3]))))
data &lt;- data[ind, ]
dGR &lt;- GenomicRanges::GRanges(seqnames = S4Vectors::Rle(data[,
1]), ranges = IRanges::IRanges(start = as.numeric(data[,
2]), end = as.numeric(data[, 3])), strand = S4Vectors::Rle(rep("*",
nrow(data))))
if (!is.null(annotation)) {
input &lt;- do.call(rbind, strsplit(annotation[, 1],
":|-"))
if (ncol(input) &gt;= 3) {
annotation &lt;- cbind(input[, 1:3], annotation[,
2])
}
else if (ncol(input) == 2) {
annotation &lt;- cbind(input[, c(1, 2, 2)], annotation[,
2])
}
else {
stop("Your input 'annotation.file' does not meet the format
'chr:start-end'!\n")
}
anno_ls &lt;- split(x = annotation[, -4], f = annotation[,
4])
aGR &lt;- base::lapply(anno_ls, function(x) {
ind &lt;- suppressWarnings(which(!is.na(as.numeric(x[,
2])) &amp; !is.na(as.numeric(x[, 3]))))
x &lt;- x[ind, ]
gr &lt;- GenomicRanges::GRanges(seqnames = S4Vectors::Rle(x[,
1]), ranges = IRanges::IRanges(start = as.numeric(x[,
2]), end = as.numeric(x[, 3])), strand = S4Vectors::Rle(rep("*",
nrow(x))))
})
}
else {
if (class(GR.annotation) == "GRanges") {
aGR &lt;- GR.annotation
}
else {
if (is.na(GR.annotation)) {
stop("Please specify annotation RData!\n")
}
else {
if (length(GR.annotation) &gt; 1) {
message("\tONLY the first specified annotation RData will be used!\n")
GR.annotation &lt;- GR.annotation[1]
}
aGR &lt;- xRDataLoader(RData.customised = GR.annotation,
verbose = verbose, RData.location = RData.location)
if (is.null(aGR)) {
stop("Your specified annotation RData does not exist!\n")
}
}
}
}
if (!is.null(background)) {
input &lt;- do.call(rbind, strsplit(background[, 1],
":|-"))
if (ncol(input) &gt;= 3) {
background &lt;- input
}
else if (ncol(input) == 2) {
background &lt;- cbind(input, input[, 2])
}
else {
stop("Your input 'background.file' does not meet the format
'chr:start-end'!\n")
}
ind &lt;- suppressWarnings(which(!is.na(as.numeric(background[,
2])) &amp; !is.na(as.numeric(background[, 3]))))
background &lt;- background[ind, ]
bGR &lt;- GenomicRanges::GRanges(seqnames = S4Vectors::Rle(background[,
1]), ranges = IRanges::IRanges(start = as.numeric(background[,
2]), end = as.numeric(background[, 3])), strand =
S4Vectors::Rle(rep("*",
nrow(data))))
}
else {
bGR &lt;- NULL
}
}
else if (format.file == "bed") {
ind &lt;- suppressWarnings(which(!is.na(as.numeric(data[,
2])) &amp; !is.na(as.numeric(data[, 3]))))
data &lt;- data[ind, ]
dGR &lt;- GenomicRanges::GRanges(seqnames = S4Vectors::Rle(data[,
1]), ranges = IRanges::IRanges(start = as.numeric(data[,
2]) + 1, end = as.numeric(data[, 3])), strand = S4Vectors::Rle(rep("*",
nrow(data))))
if (!is.null(annotation)) {
anno_ls &lt;- split(x = annotation[, -4], f = annotation[,
4])
aGR &lt;- base::lapply(anno_ls, function(x) {
ind &lt;- suppressWarnings(which(!is.na(as.numeric(x[,
2])) &amp; !is.na(as.numeric(x[, 3]))))
x &lt;- x[ind, ]
gr &lt;- GenomicRanges::GRanges(seqnames = S4Vectors::Rle(x[,
1]), ranges = IRanges::IRanges(start = as.numeric(x[,
2]) + 1, end = as.numeric(x[, 3])), strand = S4Vectors::Rle(rep("*",
nrow(x))))
})
}
else {
if (class(GR.annotation) == "GRanges") {
aGR &lt;- GR.annotation
}
else {
if (is.na(GR.annotation)) {
stop("Please specify annotation RData!\n")
}
else {
if (length(GR.annotation) &gt; 1) {
message("\tONLY the first specified annotation RData will be used!\n")
GR.annotation &lt;- GR.annotation[1]
}
aGR &lt;- xRDataLoader(RData.customised = GR.annotation,
verbose = verbose, RData.location = RData.location)
if (is.null(aGR)) {
stop("Your specified annotation RData does not exist!\n")
}
}
}
}
if (!is.null(background)) {
ind &lt;- suppressWarnings(which(!is.na(as.numeric(background[,
2])) &amp; !is.na(as.numeric(background[, 3]))))
background &lt;- background[ind, ]
bGR &lt;- GenomicRanges::GRanges(seqnames = S4Vectors::Rle(background[,
1]), ranges = IRanges::IRanges(start = as.numeric(background[,
2]) + 1, end = as.numeric(background[, 3])),
strand = S4Vectors::Rle(rep("*", nrow(data))))
}
else {
bGR &lt;- NULL
}
}
else if (format.file == "GRanges") {
dGR &lt;- data
if (!is.null(annotation)) {
aGR &lt;- annotation
}
else {
if (class(GR.annotation) == "GRanges") {
aGR &lt;- GR.annotation
}
else {
if (is.na(GR.annotation)) {
stop("Please specify annotation RData!\n")
}
else {
if (length(GR.annotation) &gt; 1) {
message("\tONLY the first specified annotation RData will be used!\n")
GR.annotation &lt;- GR.annotation[1]
}
aGR &lt;- xRDataLoader(RData.customised = GR.annotation,
verbose = verbose, RData.location = RData.location)
if (is.null(aGR)) {
stop("Your specified annotation RData does not exist!\n")
}
}
}
}
if (!is.null(background)) {
bGR &lt;- background
}
else {
bGR &lt;- NULL
}
}
mergeOverlaps &lt;- function(qGR, sGR, maxgap = 0L, minoverlap = 1L) {
hits &lt;- as.matrix(as.data.frame(GenomicRanges::findOverlaps(query =
qGR,
subject = sGR, maxgap = maxgap, minoverlap = minoverlap,
type = "any", select = "all", ignore.strand = T)))
qhits &lt;- qGR[hits[, 1]]
shits &lt;- sGR[hits[, 2]]
oGR &lt;- IRanges::pintersect(qhits, shits, ignore.strand = T)
IRanges::reduce(oGR)
}
doBinomialTest &lt;- function(X, K, M, N, lower.tail) {
N &lt;- max(N, M)
p.value &lt;- ifelse(K == 0 || M == 0 || N == 0, 1, stats::pbinom(X,
K, M/N, lower.tail = lower.tail, log.p = F))
return(p.value)
}
if (!is.na(build.conversion)) {
if (verbose) {
message(sprintf("\tdata genomic regions: lifted over via genome build
conversion `%s`",
build.conversion), appendLF = T)
}
dGR &lt;- xLiftOver(data.file = dGR, format.file = "GRanges",
build.conversion = build.conversion, merged = F,
verbose = verbose, RData.location = RData.location)
if (!is.null(annotation.file)) {
if (verbose) {
message(sprintf("\tannotation genomic regions: lifted over via genome
build conversion `%s`",
build.conversion), appendLF = T)
}
aGR &lt;- lapply(aGR, function(gr) {
xLiftOver(data.file = gr, format.file = "GRanges",
build.conversion = build.conversion, merged = F,
verbose = verbose, RData.location = RData.location)
})
}
if (!is.null(bGR)) {
if (verbose) {
message(sprintf("\tbackground genomic regions: lifted over via genome
build conversion `%s`",
build.conversion), appendLF = T)
}
bGR &lt;- xLiftOver(data.file = bGR, format.file = "GRanges",
build.conversion = build.conversion, merged = F,
verbose = verbose, RData.location = RData.location)
}
}
if (verbose) {
now &lt;- Sys.time()
message(sprintf("Third, define the background (%s) ...",
as.character(now)), appendLF = T)
}
dGR_reduced &lt;- IRanges::reduce(dGR)
aGR_reduced &lt;- base::lapply(aGR, function(x) {
IRanges::reduce(x)
})
if (is.null(bGR)) {
if (verbose) {
now &lt;- Sys.time()
message(sprintf("\tall annotatable regions (by default) are used as the
background (%s) ...",
as.character(now)), appendLF = T)
}
aGRL &lt;- GenomicRanges::GRangesList(aGR_reduced)
bGR_reduced &lt;- IRanges::reduce(BiocGenerics::unlist(aGRL))
}
else {
bGR_reduced &lt;- IRanges::reduce(bGR)
aGR_reduced &lt;- base::lapply(aGR_reduced, function(gr) {
mergeOverlaps(qGR = gr, sGR = bGR_reduced, maxgap = 0L,
minoverlap = 1L)
})
if (background.annotatable.only) {
if (verbose) {
now &lt;- Sys.time()
message(sprintf("\tthe given background regions but restricted to the
annotatable are used as the background (%s) ...",
as.character(now)), appendLF = T)
}
aGRL &lt;- GenomicRanges::GRangesList(aGR_reduced)
bGR_reduced &lt;- IRanges::reduce(BiocGenerics::unlist(aGRL))
}
else {
if (verbose) {
now &lt;- Sys.time()
message(sprintf("\tthe given background regions are used as the
background (%s) ...",
as.character(now)), appendLF = T)
}
}
}
dGR_reduced &lt;- mergeOverlaps(qGR = dGR_reduced, sGR = bGR_reduced,
maxgap = 0L, minoverlap = 1L)
oGR_reduced &lt;- base::lapply(aGR_reduced, function(gr) {
mergeOverlaps(qGR = gr, sGR = dGR_reduced, maxgap = 0L,
minoverlap = 1L)
})
if (verbose) {
now &lt;- Sys.time()
message(sprintf("Forth, perform enrichment analysis at '%s' resolution
with '%s' p-values (%s) ...",
resolution, p.tail, as.character(now)), appendLF = T)
}
if (resolution == "bases") {
data_nBases &lt;- sum(as.numeric(IRanges::width(dGR_reduced)))
overlap_nBases &lt;- base::sapply(oGR_reduced, function(gr) {
sum(as.numeric(IRanges::width(gr)))
})
annotation_nBases &lt;- base::sapply(aGR_reduced, function(gr) {
sum(as.numeric(IRanges::width(gr)))
})
background_nBases &lt;- sum(as.numeric(IRanges::width(bGR_reduced)))
if (verbose) {
now &lt;- Sys.time()
message(sprintf("\tthe number of bases: data (%d)",
data_nBases), appendLF = T)
message(sprintf("\tthe number of annotations: %d",
length(annotation_nBases)), appendLF = T)
}
}
else if (resolution == "regions") {
data_nBases &lt;- length(dGR_reduced)
overlap_nBases &lt;- base::sapply(oGR_reduced, length)
annotation_nBases &lt;- base::sapply(aGR_reduced, length)
background_nBases &lt;- length(bGR_reduced)
if (verbose) {
now &lt;- Sys.time()
message(sprintf("\tthe number of regions: data (%d)",
data_nBases), appendLF = T)
message(sprintf("\tthe number of annotations: %d",
length(annotation_nBases)), appendLF = T)
}
}
else if (resolution == "hybrid") {
data_nBases &lt;- length(dGR_reduced)
overlap_nBases &lt;- base::sapply(oGR_reduced, length)
annotation_nBases &lt;- base::sapply(aGR_reduced, function(gr) {
sum(as.numeric(IRanges::width(gr)))
})
background_nBases &lt;- sum(as.numeric(IRanges::width(bGR_reduced)))
if (verbose) {
now &lt;- Sys.time()
message(sprintf("\tthe number of regions: data (%d)",
data_nBases), appendLF = T)
message(sprintf("\tthe number of annotations: %d",
length(annotation_nBases)), appendLF = T)
}
}
res_ls &lt;- base::lapply(1:length(overlap_nBases), function(i) {
X &lt;- as.numeric(overlap_nBases[i])
K &lt;- data_nBases
M &lt;- as.numeric(annotation_nBases[i])
N &lt;- background_nBases
x.exp &lt;- K * M/N
var.exp &lt;- K * M/N * (N - M)/N * (N - K)/(N - 1)
if (is.na(var.exp)) {
z.score &lt;- 0
}
else {
if (var.exp != 0) {
suppressWarnings(z.score &lt;- (X - x.exp)/sqrt(var.exp))
}
else {
z.score &lt;- 0
}
}
if (is.na(z.score)) {
z.score &lt;- 0
}
lower.tail &lt;- F
if (p.tail == "two-tails") {
if (X &lt; x.exp) {
lower.tail &lt;- T
}
}
p.value &lt;- doBinomialTest(X, K, M, N, lower.tail)
c(X, K, M, N, X/K, M/N, (X/K)/(M/N), z.score, p.value)
})
res_df &lt;- do.call(rbind, res_ls)
enrichment_df &lt;- data.frame(names(overlap_nBases), res_df,
stringsAsFactors = F)
colnames(enrichment_df) &lt;- c("name", "nOverlap", "nData",
"nAnno", "nBG", "obsProb", "expProb", "fc", "zscore",
"pvalue")
p.adjust.method = c("BH", "BY", "bonferroni", "holm", "hochberg",
"hommel")[1]
pvals &lt;- enrichment_df$pvalue
adjpvals &lt;- stats::p.adjust(pvals, method = p.adjust.method)
enrichment_df$adjp &lt;- adjpvals
enrichment_df$zscore &lt;- signif(enrichment_df$zscore, digits = 3)
pvals &lt;- enrichment_df$pvalue
adjpvals &lt;- enrichment_df$adjp
pvals &lt;- signif(pvals, digits = 2)
adjpvals &lt;- signif(adjpvals, digits = 2)
pvals &lt;- base::sapply(pvals, function(x) {
if (x &lt; 0.1 &amp; x != 0) {
as.numeric(format(x, scientific = T))
}
else {
x
}
})
adjpvals &lt;- base::sapply(adjpvals, function(x) {
if (x &lt; 0.1 &amp; x != 0) {
as.numeric(format(x, scientific = T))
}
else {
x
}
})
enrichment_df$pvalue &lt;- pvals
enrichment_df$adjp &lt;- adjpvals
endT &lt;- Sys.time()
message(paste(c("\nEnd at ", as.character(endT)), collapse = ""),
appendLF = T)
runTime &lt;- as.numeric(difftime(strptime(endT, "%Y-%m-%d
%H:%M:%S"),
strptime(startT, "%Y-%m-%d %H:%M:%S"), units = "secs"))
message(paste(c("Runtime in total is: ", runTime, " secs\n"),
collapse = ""), appendLF = T)
res_df &lt;- enrichment_df[, c("name", "nAnno", "nOverlap",
"fc", "zscore", "pvalue", "adjp", "expProb", "obsProb")]
invisible(res_df)
}
</pre>


</body></html>
