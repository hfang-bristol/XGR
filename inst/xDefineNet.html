<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title></title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for xDefineNet"><tr><td>xDefineNet</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>xDefineNet</h2>

<h3>Usage</h3>

<pre>
xDefineNet(network = c("STRING_highest", "STRING_high",
"STRING_medium", "STRING_low", "PCommonsUN_high", "PCommonsUN_medium",
"PCommonsDN_high", "PCommonsDN_medium", "PCommonsDN_Reactome",
"PCommonsDN_KEGG", "PCommonsDN_HumanCyc", "PCommonsDN_PID",
"PCommonsDN_PANTHER", "PCommonsDN_ReconX", "PCommonsDN_TRANSFAC",
"PCommonsDN_PhosphoSite", "PCommonsDN_CTD"), STRING.only = c(NA,
"neighborhood_score", "fusion_score", "cooccurence_score",
"coexpression_score", "experimental_score", "database_score",
"textmining_score")[1], weighted = FALSE, verbose = TRUE,
RData.location = "http://galahad.well.ox.ac.uk/bigdata")
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>network</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>STRING.only</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>weighted</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>verbose</code></td>
<td>


</td></tr>
<tr valign="top"><td><code>RData.location</code></td>
<td>


</td></tr>
</table>


<h3>Examples</h3>

<pre>
##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (network = c("STRING_highest", "STRING_high", "STRING_medium",
"STRING_low", "PCommonsUN_high", "PCommonsUN_medium",
"PCommonsDN_high",
"PCommonsDN_medium", "PCommonsDN_Reactome", "PCommonsDN_KEGG",
"PCommonsDN_HumanCyc", "PCommonsDN_PID", "PCommonsDN_PANTHER",
"PCommonsDN_ReconX", "PCommonsDN_TRANSFAC", "PCommonsDN_PhosphoSite",
"PCommonsDN_CTD"), STRING.only = c(NA, "neighborhood_score",
"fusion_score", "cooccurence_score", "coexpression_score",
"experimental_score", "database_score", "textmining_score")[1],
weighted = FALSE, verbose = TRUE, RData.location =
"http://galahad.well.ox.ac.uk/bigdata")
{
network &lt;- match.arg(network)
if (verbose) {
now &lt;- Sys.time()
message(sprintf("Load the network %s (%s) ...", network,
as.character(now)), appendLF = TRUE)
}
if (length(grep("STRING", network, perl = TRUE)) &gt; 0) {
g &lt;- xRDataLoader(RData.customised = "org.Hs.string",
RData.location = RData.location, verbose = verbose)
flag &lt;- unlist(strsplit(network, "_"))[2]
if (flag == "highest") {
eval(parse(text = "g &lt;- igraph::subgraph.edges(g,
eids=E(g)[combined_score&gt;=900])"))
}
else if (flag == "high") {
eval(parse(text = "g &lt;- igraph::subgraph.edges(g,
eids=E(g)[combined_score&gt;=700])"))
}
else if (flag == "medium") {
eval(parse(text = "g &lt;- igraph::subgraph.edges(g,
eids=E(g)[combined_score&gt;=400])"))
}
else if (flag == "low") {
eval(parse(text = "g &lt;- igraph::subgraph.edges(g,
eids=E(g)[combined_score&gt;=150])"))
}
default.STRING.only &lt;- c("neighborhood_score", "fusion_score",
"cooccurence_score", "coexpression_score", "experimental_score",
"database_score", "textmining_score")
ind &lt;- match(default.STRING.only, STRING.only)
STRING.only &lt;- default.STRING.only[!is.na(ind)]
if (length(STRING.only) &gt; 0) {
x &lt;- sapply(STRING.only, function(x) paste0(x, "&gt;0"))
x &lt;- paste0(x, collapse = " | ")
x &lt;- paste0("g &lt;- igraph::subgraph.edges(g, eids=E(g)[",
x, "])")
eval(parse(text = x))
}
V(g)$name &lt;- V(g)$symbol
if (weighted) {
relations &lt;- igraph::get.data.frame(g, what = "edges")[,
c(1, 2, 10)]
colnames(relations) &lt;- c("from", "to", "weight")
}
else {
relations &lt;- igraph::get.data.frame(g, what = "edges")[,
c(1, 2)]
colnames(relations) &lt;- c("from", "to")
relations$weight &lt;- rep(1, nrow(relations))
}
g &lt;- igraph::delete_vertex_attr(g, "name")
g &lt;- igraph::delete_vertex_attr(g, "seqid")
g &lt;- igraph::delete_vertex_attr(g, "geneid")
nodes &lt;- igraph::get.data.frame(g, what = "vertices")
nodes &lt;- nodes[!duplicated(nodes), ]
g &lt;- igraph::graph.data.frame(d = relations, directed = FALSE,
vertices = nodes)
}
else if (length(grep("PCommonsUN", network, perl = TRUE)) &gt;
0) {
g &lt;- xRDataLoader(RData.customised = "org.Hs.PCommons_UN",
RData.location = RData.location, verbose = verbose)
flag &lt;- unlist(strsplit(network, "_"))[2]
if (flag == "high") {
eval(parse(text = "g &lt;- igraph::subgraph.edges(g,
eids=E(g)[in_complex_with&gt;=102 | interacts_with&gt;=102])"))
}
else if (flag == "medium") {
eval(parse(text = "g &lt;- igraph::subgraph.edges(g,
eids=E(g)[in_complex_with&gt;=101 | interacts_with&gt;=101])"))
}
relations &lt;- igraph::get.data.frame(g, what = "edges")[,
c(1, 2)]
colnames(relations) &lt;- c("from", "to")
nodes &lt;- igraph::get.data.frame(g, what = "vertices")[,
c(3, 4)]
g &lt;- igraph::graph.data.frame(d = relations, directed = FALSE,
vertices = nodes)
}
else if (length(grep("PCommonsDN", network, perl = TRUE)) &gt;
0) {
flag &lt;- unlist(strsplit(network, "_"))[2]
if (flag == "high") {
g &lt;- xRDataLoader(RData.customised = "org.Hs.PCommons_DN",
RData.location = RData.location, verbose = verbose)
eval(parse(text = "g &lt;- igraph::subgraph.edges(g,
eids=E(g)[catalysis_precedes&gt;=102 | controls_expression_of&gt;=102 |
controls_phosphorylation_of&gt;=102 | controls_state_change_of&gt;=102 |
controls_transport_of&gt;=102])"))
}
else if (flag == "medium") {
g &lt;- xRDataLoader(RData.customised = "org.Hs.PCommons_DN",
RData.location = RData.location, verbose = verbose)
eval(parse(text = "g &lt;- igraph::subgraph.edges(g,
eids=E(g)[catalysis_precedes&gt;=101 | controls_expression_of&gt;=101 |
controls_phosphorylation_of&gt;=101 | controls_state_change_of&gt;=101 |
controls_transport_of&gt;=101])"))
}
else {
g &lt;- xRDataLoader(RData.customised = "org.Hs.PCommons_DN.source",
RData.location = RData.location, verbose = verbose)
g &lt;- g[[flag]]
eval(parse(text = "g &lt;- igraph::subgraph.edges(g,
eids=E(g)[catalysis_precedes&gt;=101 | controls_expression_of&gt;=101 |
controls_phosphorylation_of&gt;=101 | controls_state_change_of&gt;=101 |
controls_transport_of&gt;=101])"))
}
relations &lt;- igraph::get.data.frame(g, what = "edges")[,
c(1, 2)]
colnames(relations) &lt;- c("from", "to")
relations$weight &lt;- rep(1, nrow(relations))
nodes &lt;- igraph::get.data.frame(g, what = "vertices")[,
c(3, 4)]
g &lt;- igraph::graph.data.frame(d = relations, directed = TRUE,
vertices = nodes)
}
invisible(g)
}
</pre>


</body></html>
